spring:
  application:
    name: BusinessAuthService
#  data:
#    redis:
#      host: localhost
#      port: 6379
  datasource:
    url: jdbc:postgresql://localhost:5432/postgres
    username: postgres
    password: 16032005
    driver-class-name: org.postgresql.Driver

  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.PostgreSQLDialect

  mail:
    host: smtp.gmail.com
    port: 587
    username:  aytacagazadehvidadi@gmail.com
    password: xudr bdqb uwrt zhxd
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true

  task:
    execution:
      thread-name-prefix: async-task-
      pool:
        core-size: 2
        max-size: 5
        queue-capacity: 10

# JWT Access Token Settings
jwt:
  secret: q0+DTRJNAJzq8FXZHweVp8RUAEDCrEFwn7IuVyb8If70sZzmmTlRs+UE/zeq3kJzMRIrkVXtRuC14vXNAr8xfQ==
  expiration:
    ms: 300000 # 5 d?qiq? (milisaniy?)

  # Refresh Token Settings
  refresh-expiration:
    ms: 604800000 # 7 g�n (milisaniy?)

# OTP Settings
otp:
  expiration-seconds: 180 # 3 d?qiq?


logging:
  level:
    com.example.businessauthService: DEBUG # �z paketiniz ���n DEBUG loglar?
    org.springframework.security: INFO # Spring Security loglar?
    org.hibernate.SQL: DEBUG # SQL sorgular?n? g�st?rm?k ���n
    org.hibernate.orm.jdbc.bind: TRACE # SQL parameterl?rini g�st?rm?k ���n

# SpringDoc OpenAPI (Swagger UI) Konfiqurasiyas?
springdoc:
  swagger-ui:
    path: /swagger-ui.html
    disable-swagger-default-url: true
  api-docs:
    path: /v3/api-docs

server:
  port: 9191
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.5'
    id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-mail'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    implementation 'io.jsonwebtoken:jjwt-impl:0.11.5'
    implementation 'io.jsonwebtoken:jjwt-jackson:0.11.5'
    implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-data-redis'
    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'org.postgresql:postgresql'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
    useJUnitPlatform()
}
package com.example.businessauthservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BusinessAuthServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(BusinessAuthServiceApplication.class, args);
    }

}
package com.example.businessauthservice.config;


import com.example.businessauthservice.filter.JwtAuthFilter;
import com.example.businessauthservice.repository.BusinnessUserRepository;
import com.example.businessauthservice.service.BusinesssUserDetailsSerivice;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@SuppressWarnings("removal")
@Configuration
@RequiredArgsConstructor
@EnableMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    private final JwtAuthFilter jwtAuthFilter;
    private final BusinnessUserRepository businnessUserRepository;

    @Bean
    public UserDetailsService userDetailsService(BusinnessUserRepository businnessUserRepository) {
        return new BusinesssUserDetailsSerivice(businnessUserRepository);
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception{
        return http
                .csrf().disable()
                .headers(headers -> headers.frameOptions().disable())
                .authorizeHttpRequests()
                .requestMatchers(
                        "/api/auth/**",
                        "/h2-console/**",
                        "/swagger-ui/**",
                        "/swagger-ui.html",
                        "/v3/api-docs/**",
                        "/v3/api-docs.yaml",
                        "/swagger-resources/**",
                        "/webjars/**"
                ).permitAll()
                .requestMatchers("/api/business/**").hasAnyRole("BUSINESS_OWNER")
                .anyRequest().authenticated()
                .and()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .and()
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider();
        authenticationProvider.setUserDetailsService(userDetailsService(businnessUserRepository));
        authenticationProvider.setPasswordEncoder(passwordEncoder());
        return authenticationProvider;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }


    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return web -> web.ignoring().requestMatchers("/h2-console/**");
    }
}
package com.example.businessauthservice.config;

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Contact;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.info.License;
import io.swagger.v3.oas.models.security.SecurityScheme;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("BusinessAuthService API")
                        .version("1.0.0")
                        .description("Authentication and User Management Service API Documentation")
                        .termsOfService("http://swagger.io/terms/")
                        .contact(new Contact().name("Your Name").email("your.email@example.com"))
                        .license(new License().name("Apache 2.0").url("http://springdoc.org")))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth")) // JWT üçün tələb əlavə edir
                .components(new Components()
                        .addSecuritySchemes("bearerAuth", new SecurityScheme() // JWT üçün security scheme təyin edir
                                .type(SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}
package com.example.businessauthservice.controller;

import com.example.businessauthservice.model.dto.*;
import com.example.businessauthservice.service.BusinessAuthService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
@Slf4j
@Validated // MethodArgumentNotValidException GlobalExceptionHandler tərəfindən tutulacaq
public class BusinessAuthController {

    private final BusinessAuthService authService;

    @PostMapping("/signup")
    public ResponseEntity<AuthResponse> signup(@Valid @RequestBody Signup signupRequest) {
        log.info("Signup request received for username: {}", signupRequest.getUserName());
        AuthResponse response = authService.signup(signupRequest);
        return new ResponseEntity<>(response, HttpStatus.CREATED);
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@Valid @RequestBody Login loginRequest) {
        log.info("Login request received for identifier: {}", loginRequest.getIdentifier());
        AuthResponse response = authService.login(loginRequest);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<AuthResponse> refreshToken(@Valid @RequestBody RefreshTokenRequest request) {
        log.info("Refresh token request received for token: {}", request.getToken());
        AuthResponse response = authService.refreshToken(request);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/send-otp")
    public ResponseEntity<AuthResponse> sendOtp(@Valid @RequestBody OtpSendRequest request) {
        log.info("Send OTP request received for identifier: {} with type: {}", request.getIdentifier(), request.getOtpType());
        AuthResponse response = authService.sendOtp(request);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/verify-otp")
    public ResponseEntity<AuthResponse> verifyOtp(@Valid @RequestBody OtpVerificationRequest request) {
        log.info("Verify OTP request received for identifier: {} with type: {}", request.getIdentifier(), request.getOtpType());
        AuthResponse response = authService.verifyOtp(request);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @PostMapping("/reset-password")
    public ResponseEntity<AuthResponse> resetPassword(@Valid @RequestBody ResetPasswordRequest request) {
        log.info("Password reset request received for identifier: {}", request.getIdentifier());
        AuthResponse response = authService.resetPassword(request);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }


    @PostMapping("/logout")
    @PreAuthorize("isAuthenticated()") // Yalnız daxil olmuş istifadəçilər üçün
    public ResponseEntity<AuthResponse> logout(Authentication authentication) {
        String username = authentication.getName();
        log.info("Logout request received for user: {}", username);
        AuthResponse response = authService.logout(username);
        return new ResponseEntity<>(response, HttpStatus.OK);
    }

    @DeleteMapping("/delete-account")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<String> deleteAccount(Authentication authentication) {
        String username = authentication.getName();
        authService.deleteAccount(username);
        return ResponseEntity.ok("Your account has been deleted successfully.");
    }


    // --- Demo endpoint for authenticated users (Optional) ---
    @GetMapping("/test-secured-owner")
    @PreAuthorize("hasRole('BUSINESS_OWNER')") // Bu annotasiya SecurityConfig-dəki requestMatchers-i əvəz edir
    public ResponseEntity<String> testSecuredOwnerEndpoint() {
        log.info("Accessing secured endpoint with BUSINESS_OWNER role.");
        return new ResponseEntity<>("You have accessed the BUSINESS_OWNER secured endpoint!", HttpStatus.OK);
    }

    // --- Demo endpoint for any authenticated user (Optional) ---
    @GetMapping("/test-secured-user")
    @PreAuthorize("isAuthenticated()") // Hər hansı daxil olmuş istifadəçi üçün
    public ResponseEntity<String> testSecuredUserEndpoint() {
        log.info("Accessing secured endpoint for any authenticated user.");
        return new ResponseEntity<>("You have accessed a secured endpoint as an authenticated user!", HttpStatus.OK);
    }
}package com.example.businessauthservice.exception;

 import lombok.AllArgsConstructor;
 import lombok.Data;
 import lombok.NoArgsConstructor;

 import java.time.LocalDateTime;

 @Data
 @AllArgsConstructor
 @NoArgsConstructor
 public class ErrorResponse {
     private int status;
     private String message;
     private LocalDateTime timestamp;
 }package com.example.businessauthservice.exception;

  import lombok.extern.slf4j.Slf4j;
  import org.springframework.http.HttpStatus;
  import org.springframework.http.ResponseEntity;
  import org.springframework.security.authentication.BadCredentialsException;
  import org.springframework.web.bind.MethodArgumentNotValidException;
  import org.springframework.web.bind.annotation.ExceptionHandler;
  import org.springframework.web.bind.annotation.RestControllerAdvice;

  import java.time.LocalDateTime;
  import java.util.HashMap;
  import java.util.Map;

  @RestControllerAdvice
  @Slf4j
  public class GlobalExceptionHandler {

      // Custom Exception Handling
      @ExceptionHandler(UserAlreadyExistsException.class)
      public ResponseEntity<ErrorResponse> handleUserAlreadyExistsException(UserAlreadyExistsException ex) {
          log.error("UserAlreadyExistsException: {}", ex.getMessage());
          ErrorResponse errorResponse = new ErrorResponse(
                  HttpStatus.CONFLICT.value(),
                  ex.getMessage(),
                  LocalDateTime.now()
          );
          return new ResponseEntity<>(errorResponse, HttpStatus.CONFLICT);
      }

      @ExceptionHandler(OtpException.class)
      public ResponseEntity<ErrorResponse> handleOtpException(OtpException ex) {
          log.error("OtpException: {}", ex.getMessage());
          ErrorResponse errorResponse = new ErrorResponse(
                  HttpStatus.BAD_REQUEST.value(), // 400 Bad Request
                  ex.getMessage(),
                  LocalDateTime.now()
          );
          return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);
      }

      @ExceptionHandler(ResourceNotFoundException.class)
      public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException ex) {
          log.error("ResourceNotFoundException: {}", ex.getMessage());
          ErrorResponse errorResponse = new ErrorResponse(
                  HttpStatus.NOT_FOUND.value(), // 404 Not Found
                  ex.getMessage(),
                  LocalDateTime.now()
          );
          return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
      }

      @ExceptionHandler(InvalidTokenException.class)
      public ResponseEntity<ErrorResponse> handleInvalidTokenException(InvalidTokenException ex) {
          log.error("InvalidTokenException: {}", ex.getMessage());
          ErrorResponse errorResponse = new ErrorResponse(
                  HttpStatus.UNAUTHORIZED.value(), // 401 Unauthorized
                  ex.getMessage(),
                  LocalDateTime.now()
          );
          return new ResponseEntity<>(errorResponse, HttpStatus.UNAUTHORIZED);
      }

      // Spring Security BadCredentialsException (Login zamanı səhv şifrə/username)
      @ExceptionHandler(BadCredentialsException.class)
      public ResponseEntity<ErrorResponse> handleBadCredentialsException(BadCredentialsException ex) {
          log.error("BadCredentialsException: {}", ex.getMessage());
          ErrorResponse errorResponse = new ErrorResponse(
                  HttpStatus.UNAUTHORIZED.value(), // 401 Unauthorized
                  "Invalid username/email or password.", // Daha ümumi mesaj verin
                  LocalDateTime.now()
          );
          return new ResponseEntity<>(errorResponse, HttpStatus.UNAUTHORIZED);
      }

      // Bean Validation (jakarta.validation) xətalarını idarə etmək üçün
      @ExceptionHandler(MethodArgumentNotValidException.class)
      public ResponseEntity<Map<String, String>> handleValidationExceptions(MethodArgumentNotValidException ex) {
          log.error("Validation failed: {}", ex.getMessage());
          Map<String, String> errors = new HashMap<>();
          ex.getBindingResult().getFieldErrors().forEach(error ->
                  errors.put(error.getField(), error.getDefaultMessage()));
          return new ResponseEntity<>(errors, HttpStatus.BAD_REQUEST);
      }

      // Ümumi Xəta İdarəetməsi (Hər hansı digər gözlənilməz xətalar üçün)
      @ExceptionHandler(Exception.class)
      public ResponseEntity<ErrorResponse> handleGlobalException(Exception ex) {
          log.error("An unexpected error occurred: {}", ex.getMessage(), ex); // Xətanın stack trace-ni loqa yazın
          ErrorResponse errorResponse = new ErrorResponse(
                  HttpStatus.INTERNAL_SERVER_ERROR.value(), // 500 Internal Server Error
                  "An unexpected error occurred. Please try again later.",
                  LocalDateTime.now()
          );
          return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
      }
  }package com.example.businessauthservice.exception;

   public class InvalidTokenException extends RuntimeException {
       public InvalidTokenException(String message) {
           super(message);
       }
   }
package com.example.businessauthservice.exception;

public class OtpException extends RuntimeException {
    public OtpException(String message) {
        super(message);
    }
}
package com.example.businessauthservice.exception;

public class UserAlreadyExistsException extends RuntimeException {
    public UserAlreadyExistsException(String message) {
        super(message);
    }
}
package com.example.businessauthservice.exception;

public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
package com.example.businessauthservice.filter;

import com.example.businessauthservice.service.BusinesssUserDetailsSerivice;
import com.example.businessauthservice.service.JwtService;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
@RequiredArgsConstructor
public class JwtAuthFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final BusinesssUserDetailsSerivice businesssUserDetailsSerivice;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        final String authHeader = request.getHeader("Authorization");
        final String token;
        final String username;

        if (authHeader == null || !authHeader.startsWith("Bearer ")) {
            filterChain.doFilter(request, response);
            return;
        }

        token = authHeader.substring(7);
        username = jwtService.extractUsername(token);

        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
            UserDetails userDetails = businesssUserDetailsSerivice.loadUserByUsername(username);

            if (jwtService.validateToken(token, userDetails)) {
                UsernamePasswordAuthenticationToken authToken =
                        new UsernamePasswordAuthenticationToken(
                                userDetails,
                                null,
                                userDetails.getAuthorities()
                        );
                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }

    @Override
    protected boolean shouldNotFilter(HttpServletRequest request) throws ServletException {
        String path = request.getRequestURI();
        return path.equals("/api/auth/login") ||
                path.equals("/api/auth/signup") ||
                path.equals("/api/auth/send-otp") ||
                path.equals("/api/auth/verify-otp") ||
                path.equals("/api/auth/reset-password") ||
                path.startsWith("/h2-console") ||
                path.startsWith("/swagger-ui") ||
                path.startsWith("/v3/api-docs") ||
                path.startsWith("/swagger-resources") ||
                path.startsWith("/webjars");
    }
}
package com.example.businessauthservice.model.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AuthResponse {
    private String accessToken;
    private String refreshToken;
    private String username;
    private String email;
    private String role;
    private Boolean isAccountEnabled;
    private String message;
}package com.example.businessauthservice.model.dto;

 import jakarta.validation.constraints.NotBlank;
 import jakarta.validation.constraints.Pattern;
 import lombok.Data;

 @Data
 public class Login {

     @NotBlank(message = "Identifier (username or email) cannot be blank")
     private String identifier;

     @NotBlank(message = "Password cannot be blank")
     @Pattern(
             regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+])[A-Za-z\\d!@#$%^&*()_+]{8,}$",
             message = "Password must be at least 8 characters long and contain an uppercase letter, a lowercase letter, a digit, and a special character (!@#$%^&*()_+).")
     private String password;

     private Boolean rememberMe = false;


 }
package com.example.businessauthservice.model.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class OtpSendRequest {
    @NotBlank(message = "Identifier (username or email) cannot be blank")
    private String identifier;
    @NotBlank(message = "Send method must be 'email' or 'phone'")
    private String sendMethod; // 'email'
    @NotBlank(message = "OTP type cannot be blank (e.g., ACCOUNT_CONFIRMATION, PASSWORD_RESET)")
    private String otpType; // ACCOUNT_CONFIRMATION, PASSWORD_RESET
}package com.example.businessauthservice.model.dto;

 import jakarta.validation.constraints.NotBlank;
 import lombok.Data;

 @Data
 public class OtpVerificationRequest {

     @NotBlank(message = "Identifier (username or email) cannot be blank")
     private String identifier;
     @NotBlank(message = "OTP code cannot be blank")
     private String otpCode;
     @NotBlank(message = "OTP type cannot be blank")
     private String otpType;
 }
package com.example.businessauthservice.model.dto;

import lombok.Data;

@Data
public class RefreshTokenRequest {

    private String token;
}
package com.example.businessauthservice.model.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import lombok.Data;

@Data
public class ResetPasswordRequest {

    @NotBlank(message = "Identifier (username or email) cannot be blank")
    private String identifier;

    @NotBlank(message = "Password cannot be blank")
    @Pattern(
            regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+])[A-Za-z\\d!@#$%^&*()_+]{8,}$",
            message = "Password must be at least 8 characters long and contain an uppercase letter, a lowercase letter, a digit, and a special character (!@#$%^&*()_+)."
    )
    private String newPassword;

}
package com.example.businessauthservice.model.dto;

import com.example.businessauthservice.model.enumeration.Roles;
import jakarta.validation.constraints.*;
import lombok.Data;

@Data

public class Signup {

    @NotBlank(message = "Username cannot be blank")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    private String userName;

    @NotBlank(message = "Email cannot be blank")
    @Email(message = "Email must be a valid email address")
    private String email;

    @NotBlank(message = "Password cannot be blank")
    @Pattern(
            regexp = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[!@#$%^&*()_+])[A-Za-z\\d!@#$%^&*()_+]{8,}$",
            message = "Password must be at least 8 characters long and contain an uppercase letter, a lowercase letter, a digit, and a special character (!@#$%^&*()_+)."
    )
    private String password;

    @NotBlank(message = "Role cannot be blank")
    @Pattern(regexp = "CUSTOMER|BUSINESS_OWNER", message = "Invalid role selected. Must be CUSTOMER or BUSINESS_OWNER.")
    private String selectedRole;

}
package com.example.businessauthservice.model.entity;

import com.example.businessauthservice.model.enumeration.Roles;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "users")
public class BusinessUser{

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 50,unique = true)
    private String userName;

    @Column(unique = true, length = 100)
    private String email;

    @Column(nullable = false, length = 120)
    private String password;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Roles roles;

    @Builder.Default
    @Column(nullable = false)
    private boolean enabled = false;

}package com.example.businessauthservice.model.entity;

 import jakarta.persistence.*;
 import lombok.AllArgsConstructor;
 import lombok.Builder;
 import lombok.Data;
 import lombok.NoArgsConstructor;

 import java.time.Instant;

 @Data
 @Builder
 @NoArgsConstructor
 @AllArgsConstructor
 @Entity
 @Table(name = "otps") // Artıq uniqueConstraints yoxdur
 public class Otp {

     @Id
     @GeneratedValue(strategy = GenerationType.IDENTITY)
     private Long id;

     // identifier unik olmasın, çünki bir user üçün bir neçə fərqli növ OTP ola bilər.
     // @Column(nullable = false, unique = true) // Bu sətri silin!
     @Column(nullable = false) // identifier artıq unique deyil
     private String identifier; // Email və ya Username (hansı ilə OTP göndərilibsə)

     @Column(nullable = false)
     private String otpCode;

     @Column(nullable = false)
     private Instant expiryDate;

     @Column(nullable = false)
     private String otpType; // Məsələn: "ACCOUNT_CONFIRMATION", "PASSWORD_RESET"

     @Builder.Default
     @Column(nullable = false)
     private boolean used = false; // OTP istifadə edilibmi?
 }// RefreshToken.java (Düzəliş edilmiş versiya)
  package com.example.businessauthservice.model.entity;

  import jakarta.persistence.*;
  import lombok.AllArgsConstructor;
  import lombok.Builder;
  import lombok.Data;
  import lombok.NoArgsConstructor;

  import java.time.Instant;

  @Entity
  @Data
  @AllArgsConstructor
  @NoArgsConstructor
  @Builder
  public class RefreshToken {

      @Id
      @GeneratedValue(strategy = GenerationType.IDENTITY)
      private int id;

      @Column(nullable = false, unique = true)
      private String token;

      @Column(nullable = false)
      private Instant expiryDate;

      @OneToOne
      @JoinColumn(name = "user_id", referencedColumnName = "id", nullable = false)
      private BusinessUser user;
  }package com.example.businessauthservice.model.enumeration;

   public enum Roles {
       CUSTOMER,
       BUSINESS_OWNER
   }
package com.example.businessauthservice.repository;

import com.example.businessauthservice.model.entity.BusinessUser;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface BusinnessUserRepository extends JpaRepository<BusinessUser,Long> {

    Optional<BusinessUser> findByUserName(String userName);
    Optional<BusinessUser> findByEmail(String email);

}
package com.example.businessauthservice.repository;

import com.example.businessauthservice.model.entity.Otp;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.Optional;

@Repository
public interface OtpRepository extends JpaRepository<Otp, Long> {

    Optional<Otp> findByIdentifierAndOtpTypeAndUsedFalseAndExpiryDateAfter(String identifier, String otpType, Instant now);

    Optional<Otp> findByIdentifierAndOtpType(String identifier, String otpType);
}package com.example.businessauthservice.repository;

 import com.example.businessauthservice.model.entity.BusinessUser;
 import com.example.businessauthservice.model.entity.RefreshToken;
 import org.springframework.data.jpa.repository.JpaRepository;
 import org.springframework.stereotype.Repository;

 import java.util.Optional;

 @Repository
 public interface RefreshTokenRepository extends JpaRepository<RefreshToken, Integer> {
     Optional<RefreshToken> findByToken(String token);
     Optional<RefreshToken> findByUser(BusinessUser user); // BU ƏLAVƏ EDİLMƏLİDİR!
     void deleteByUser(BusinessUser user);
 }package com.example.businessauthservice.service;

  import com.example.businessauthservice.exception.OtpException;
  import com.example.businessauthservice.exception.ResourceNotFoundException;
  import com.example.businessauthservice.exception.UserAlreadyExistsException;
  import com.example.businessauthservice.model.dto.*;
  import com.example.businessauthservice.model.entity.BusinessUser;
  import com.example.businessauthservice.model.entity.Otp;
  import com.example.businessauthservice.model.entity.RefreshToken;
  import com.example.businessauthservice.model.enumeration.Roles;
  import com.example.businessauthservice.repository.BusinnessUserRepository;
  import com.example.businessauthservice.repository.OtpRepository;
  import com.example.businessauthservice.repository.RefreshTokenRepository;
  import lombok.RequiredArgsConstructor;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.security.authentication.AuthenticationManager;
  import org.springframework.security.authentication.BadCredentialsException;
  import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
  import org.springframework.security.core.Authentication;
  import org.springframework.security.core.userdetails.UsernameNotFoundException;
  import org.springframework.security.crypto.password.PasswordEncoder;
  import org.springframework.stereotype.Service;
  import org.springframework.transaction.annotation.Transactional;

  import java.time.Instant;
  import java.time.temporal.ChronoUnit;
  import java.util.Random;

  @Service
  @RequiredArgsConstructor
  @Slf4j
  public class BusinessAuthService {

      private final BusinnessUserRepository businnessUserRepository;
      private final PasswordEncoder passwordEncoder;
      private final JwtService jwtService;
      private final RefreshTokenService refreshTokenService;
      private final AuthenticationManager authenticationManager;
      private final EmailService emailService;
      private final OtpRepository otpRepository;
      private final RefreshTokenRepository refreshTokenRepository;

      // --- Authentication and Authorization Flows ---

      @Transactional
      public AuthResponse signup(Signup signupRequest) {
          log.info("Attempting to sign up user: {}", signupRequest.getUserName());

          businnessUserRepository.findByUserName(signupRequest.getUserName())
                  .ifPresent(user -> {
                      log.warn("Signup failed: Username '{}' already exists.", signupRequest.getUserName());
                      throw new UserAlreadyExistsException("Username '" + signupRequest.getUserName() + "' already exists.");
                  });

          businnessUserRepository.findByEmail(signupRequest.getEmail())
                  .ifPresent(user -> {
                      log.warn("Signup failed: Email '{}' already exists.", signupRequest.getEmail());
                      throw new UserAlreadyExistsException("Email '" + signupRequest.getEmail() + "' already exists.");
                  });

          // Yeni əlavə olunan məntiq: Front-end-dən gələn rolu təyin etmək
          Roles assignedRole;
          try {
              assignedRole = Roles.valueOf(signupRequest.getSelectedRole().toUpperCase());
          } catch (IllegalArgumentException e) {
              log.warn("Signup failed: Invalid role provided from frontend: {}", signupRequest.getSelectedRole());
              throw new IllegalArgumentException("Invalid role selected. Only 'USER' and 'BUSINESS_OWNER' are allowed.");
          }


          BusinessUser newUser = BusinessUser.builder()
                  .userName(signupRequest.getUserName())
                  .email(signupRequest.getEmail())
                  .password(passwordEncoder.encode(signupRequest.getPassword()))
                  .roles(assignedRole) // Artıq front-end-dən gələn rolu təyin edirik
                  .enabled(false) // Email təsdiqindən sonra aktiv olunacaq
                  .build();

          BusinessUser savedUser = businnessUserRepository.save(newUser);
          log.info("User '{}' with role '{}' registered successfully. Sending account confirmation OTP.", savedUser.getUserName(), savedUser.getRoles().name());

          // Hesab təsdiqi üçün OTP göndərin
          OtpSendRequest otpSendRequest = new OtpSendRequest();
          otpSendRequest.setIdentifier(savedUser.getEmail()); // OTP-ni emailə göndəririk
          otpSendRequest.setSendMethod("email");
          otpSendRequest.setOtpType("ACCOUNT_CONFIRMATION");
          sendOtp(otpSendRequest); // OTP-ni göndərmək üçün metodunuzu çağırın

          return AuthResponse.builder()
                  .username(savedUser.getUserName())
                  .email(savedUser.getEmail())
                  .role(savedUser.getRoles().name())
                  .isAccountEnabled(savedUser.isEnabled())
                  .message("User registered successfully. Please check your email for account confirmation OTP.")
                  .build();
      }

      public AuthResponse login(Login loginRequest) {
          log.info("Attempting to log in user with identifier: {}", loginRequest.getIdentifier());
          try {
              Authentication authentication = authenticationManager.authenticate(
                      new UsernamePasswordAuthenticationToken(loginRequest.getIdentifier(), loginRequest.getPassword())
              );

              BusinessUser user = businnessUserRepository.findByUserName(authentication.getName())
                      .orElseThrow(() -> {
                          log.error("Login failed: Authenticated user '{}' not found in database.", authentication.getName());
                          return new ResourceNotFoundException("Authenticated user not found.");
                      });

              if (!user.isEnabled()) {
                  log.warn("Login failed for user '{}': Account is not enabled.", user.getUserName());
                  throw new BadCredentialsException("Account is not enabled. Please confirm your email.");
              }

              String accessToken = jwtService.generateToken(user.getUserName(), user.getRoles());
              RefreshToken refreshToken = refreshTokenService.createRefreshToken(user.getUserName());
              log.info("User '{}' logged in successfully.", user.getUserName());

              return AuthResponse.builder()
                      .accessToken(accessToken)
                      .refreshToken(refreshToken.getToken())
                      .username(user.getUserName())
                      .email(user.getEmail())
                      .role(user.getRoles().name())
                      .isAccountEnabled(user.isEnabled())
                      .message("Login successful.") // Düzəliş edildi
                      .build();
          } catch (UsernameNotFoundException | BadCredentialsException e) {
              log.error("Authentication failed for identifier {}: {}", loginRequest.getIdentifier(), e.getMessage());
              throw e;
          }
      }

      @Transactional
      public AuthResponse refreshToken(RefreshTokenRequest request) {
          log.info("Attempting to refresh token: {}", request.getToken());

          RefreshToken refreshToken = refreshTokenService.findByToken(request.getToken())
                  .orElseThrow(() -> {
                      log.warn("Refresh token failed: Token not found or invalid.");
                      return new ResourceNotFoundException("Refresh token not found or invalid.");
                  });

          refreshTokenService.verifyExpiration(refreshToken);

          BusinessUser user = businnessUserRepository.findById(refreshToken.getUser().getId())
                  .orElseThrow(() -> {
                      log.warn("Refresh token failed: User not found for token.");
                      return new ResourceNotFoundException("User not found for refresh token.");
                  });

          String newAccessToken = jwtService.generateToken(user.getUserName(), user.getRoles());
          log.info("Access token refreshed successfully for user: {}", user.getUserName());

          return AuthResponse.builder()
                  .accessToken(newAccessToken)
                  .refreshToken(refreshToken.getToken()) // Refresh token eyni qalır
                  .username(user.getUserName())
                  .email(user.getEmail())
                  .role(user.getRoles().name())
                  .isAccountEnabled(user.isEnabled())
                  .message("Access token refreshed successfully.") // Düzəliş edildi
                  .build();
      }


      // --- OTP Related Flows ---

      @Transactional
      public AuthResponse sendOtp(OtpSendRequest request) {
          log.info("Attempting to send OTP to identifier: {} for type: {}", request.getIdentifier(), request.getOtpType());

          if (!"email".equalsIgnoreCase(request.getSendMethod())) {
              throw new OtpException("Only 'email' send method is currently supported.");
          }

          BusinessUser user = businnessUserRepository.findByEmail(request.getIdentifier())
                  .orElseGet(() -> businnessUserRepository.findByUserName(request.getIdentifier())
                          .orElseThrow(() -> new ResourceNotFoundException("User not found with identifier: " + request.getIdentifier())));

          // Həmin identifier və OTP növü üçün aktiv, istifadə olunmamış OTP-ləri deaktiv edin
          otpRepository.findByIdentifierAndOtpTypeAndUsedFalseAndExpiryDateAfter(user.getEmail(), request.getOtpType(), Instant.now())
                  .ifPresent(activeOtp -> {
                      activeOtp.setUsed(true); // Köhnə OTP-ni istifadə edilmiş kimi qeyd edin
                      otpRepository.save(activeOtp);
                      log.info("Deactivated previous active OTP for identifier: {} and type: {}", request.getIdentifier(), request.getOtpType());
                  });

          String otpCode = generateRandomOtp(); // OTP kodu yaradın (məsələn, 6 rəqəmli)
          Instant expiryTime = Instant.now().plus(5, ChronoUnit.MINUTES); // 5 dəqiqə etibarlılıq müddəti

          Otp otp = Otp.builder()
                  .identifier(user.getEmail()) // Emaili istifadə edin
                  .otpCode(otpCode)
                  .expiryDate(expiryTime)
                  .otpType(request.getOtpType())
                  .used(false)
                  .build();
          otpRepository.save(otp);
          log.info("Generated new OTP for identifier: {} and type: {}", request.getIdentifier(), request.getOtpType());

          // Email göndərin
          String subject = "Your OTP for " + request.getOtpType().replace("_", " ").toLowerCase();
          String body = "Hello " + user.getUserName() + ",<br><br>"
                  + "Your One-Time Password (OTP) for " + request.getOtpType().replace("_", " ").toLowerCase() + " is: <b>" + otpCode + "</b><br>"
                  + "This OTP is valid for 5 minutes. Please do not share this code with anyone.<br><br>"
                  + "Thank you.";
          emailService.sendEmail(user.getEmail(), subject, body); // Userin emailinə göndərin
          log.info("OTP email sent to: {}", user.getEmail());

          return AuthResponse.builder()
                  .username(user.getUserName())
                  .email(user.getEmail())
                  .role(user.getRoles().name())
                  .isAccountEnabled(user.isEnabled())
                  .message("OTP sent successfully to " + user.getEmail()) // Düzəliş edildi
                  .build();
      }

      @Transactional
      public AuthResponse verifyOtp(OtpVerificationRequest request) {
          log.info("Attempting to verify OTP for identifier: {} and type: {}", request.getIdentifier(), request.getOtpType());

          BusinessUser user = businnessUserRepository.findByEmail(request.getIdentifier())
                  .orElseGet(() -> businnessUserRepository.findByUserName(request.getIdentifier())
                          .orElseThrow(() -> new ResourceNotFoundException("User not found with identifier: " + request.getIdentifier())));

          // Aktiv, istifadə olunmamış və müddəti keçməmiş OTP-ni tapın
          Otp otp = otpRepository.findByIdentifierAndOtpTypeAndUsedFalseAndExpiryDateAfter(user.getEmail(), request.getOtpType(), Instant.now())
                  .orElseThrow(() -> {
                      log.warn("OTP verification failed: OTP not found, expired, or already used for identifier: {} and type: {}", request.getIdentifier(), request.getOtpType());
                      return new OtpException("Invalid, expired, or already used OTP.");
                  });

          if (!otp.getOtpCode().equals(request.getOtpCode())) {
              log.warn("OTP verification failed: Incorrect OTP code for identifier: {} and type: {}", request.getIdentifier(), request.getOtpType());
              throw new OtpException("Incorrect OTP code.");
          }

          otp.setUsed(true); // OTP-ni istifadə edilmiş kimi qeyd edin
          otpRepository.save(otp);
          log.info("OTP successfully verified for identifier: {} and type: {}", request.getIdentifier(), request.getOtpType());

          String message = "OTP verified successfully.";
          Boolean isAccountEnabled = user.isEnabled(); // Başlanğıc vəziyyət

          if ("ACCOUNT_CONFIRMATION".equals(request.getOtpType())) {
              user.setEnabled(true); // Hesabı aktiv edin
              businnessUserRepository.save(user);
              isAccountEnabled = true; // Statusu güncəlləyin
              log.info("Account for user '{}' enabled successfully.", user.getUserName());
              message = "Account confirmed successfully.";
          } else if ("PASSWORD_RESET".equals(request.getOtpType())) {
              message = "OTP verified. You can now reset your password.";
          }

          return AuthResponse.builder()
                  .username(user.getUserName())
                  .email(user.getEmail())
                  .role(user.getRoles().name())
                  .isAccountEnabled(isAccountEnabled)
                  .message(message) // Düzəliş edildi
                  .build();
      }

      @Transactional
      public AuthResponse resetPassword(ResetPasswordRequest request) {
          log.info("Attempting to reset password for identifier: {}", request.getIdentifier());

          BusinessUser user = businnessUserRepository.findByEmail(request.getIdentifier())
                  .orElseGet(() -> businnessUserRepository.findByUserName(request.getIdentifier())
                          .orElseThrow(() -> new ResourceNotFoundException("User not found with identifier: " + request.getIdentifier())));

          // Yeni şifrəni heşləyin
          user.setPassword(passwordEncoder.encode(request.getNewPassword()));
          businnessUserRepository.save(user);
          log.info("Password for user '{}' reset successfully.", user.getUserName());

          // Şifrə sıfırlandıqdan sonra bütün köhnə refresh tokenlərini silin (təhlükəsizlik üçün)
          refreshTokenService.deleteByUserId(user.getId());
          log.info("All refresh tokens for user '{}' deleted after password reset.", user.getUserName());

          // İstifadəçi daxil olub yeni token ala bilər
          return AuthResponse.builder()
                  .username(user.getUserName())
                  .email(user.getEmail())
                  .role(user.getRoles().name())
                  .isAccountEnabled(user.isEnabled())
                  .message("Password reset successfully. You can now login with your new password.") // Düzəliş edildi
                  .build();
      }

      @Transactional
      public AuthResponse logout(String username) {
          log.info("Attempting to log out user: {}", username);

          BusinessUser user = businnessUserRepository.findByUserName(username)
                  .orElseThrow(() -> {
                      log.warn("Logout failed: User '{}' not found.", username);
                      return new ResourceNotFoundException("User not found: " + username);
                  });

          // İstifadəçiyə aid bütün refresh tokenlərini silin
          refreshTokenService.deleteByUserId(user.getId());
          log.info("All refresh tokens for user '{}' deleted successfully during logout.", username);

          return AuthResponse.builder()
                  .message("User logged out successfully. All active sessions have been terminated.")
                  .build();
      }


      // --- User Management (Optional: if needed in Auth Service) ---
      @Transactional
      public BusinessUser updateUserDetails(Long id, BusinessUser updatedUser) {
          log.info("Attempting to update user details for ID: {}", id);
          return businnessUserRepository.findById(id).map(existingUser -> {

              // Email və Username unikallığını yoxlayın
              if (!existingUser.getEmail().equals(updatedUser.getEmail())) {
                  businnessUserRepository.findByEmail(updatedUser.getEmail())
                          .ifPresent(user -> {
                              log.warn("Update failed: Email '{}' already in use by another user for ID: {}.", updatedUser.getEmail(), id);
                              throw new UserAlreadyExistsException("Email '" + updatedUser.getEmail() + "' already in use by another user.");
                          });
                  existingUser.setEmail(updatedUser.getEmail());
              }

              if (!existingUser.getUserName().equals(updatedUser.getUserName())) {
                  businnessUserRepository.findByUserName(updatedUser.getUserName())
                          .ifPresent(user -> {
                              log.warn("Update failed: Username '{}' already in use by another user for ID: {}.", updatedUser.getUserName(), id);
                              throw new UserAlreadyExistsException("Username '" + updatedUser.getUserName() + "' already in use by another user.");
                          });
                  existingUser.setUserName(updatedUser.getUserName());
              }

              if (updatedUser.getRoles() != null) {
                  existingUser.setRoles(updatedUser.getRoles());
              }
              if (updatedUser.getPassword() != null && !updatedUser.getPassword().isBlank()) {
                  existingUser.setPassword(passwordEncoder.encode(updatedUser.getPassword()));
                  log.info("Password updated for user ID: {}", id);
              }
              existingUser.setEnabled(updatedUser.isEnabled());


              businnessUserRepository.save(existingUser);
              log.info("User details updated successfully for ID: {}", id);
              return existingUser;
          }).orElseThrow(() -> {
              log.warn("User update failed: User not found with ID: {}", id);
              return new ResourceNotFoundException("User not found with ID: " + id);
          });
      }

      @Transactional
      public void deleteUser(Long id) {
          log.info("Attempting to delete user with ID: {}", id);
          if (!businnessUserRepository.existsById(id)) {
              log.warn("User deletion failed: User not found with ID: {}", id);
              throw new ResourceNotFoundException("User not found with ID: " + id);
          }
          refreshTokenService.deleteByUserId(id);
          businnessUserRepository.deleteById(id);
          log.info("User with ID: {} deleted successfully.", id);
      }

      public BusinessUser findUserById(Long id) {
          log.debug("Fetching user by ID: {}", id);
          return businnessUserRepository.findById(id)
                  .orElseThrow(() -> new ResourceNotFoundException("User not found with ID: " + id));
      }

      public BusinessUser findUserByIdentifier(String identifier) {
          log.debug("Fetching user by identifier: {}", identifier);
          return businnessUserRepository.findByUserName(identifier)
                  .or(() -> businnessUserRepository.findByEmail(identifier))
                  .orElseThrow(() -> new ResourceNotFoundException("User not found with identifier: " + identifier));
      }

      @Transactional
      public void deleteAccount(String username) {
          BusinessUser user = businnessUserRepository.findByUserName(username)
                  .orElseThrow(() -> new ResourceNotFoundException("User not found: " + username));

          refreshTokenService.deleteByUserId(user.getId());
          businnessUserRepository.delete(user); // Silirik useri
          log.info("User '{}' deleted account successfully.", username);
      }


      // --- Utility Method for OTP generation ---

      private String generateRandomOtp() {
          Random random = new Random();
          int otp = 100000 + random.nextInt(900000); // 6 rəqəmli OTP
          return String.valueOf(otp);
      }
  }package com.example.businessauthservice.service;

   import com.example.businessauthservice.repository.BusinnessUserRepository;
   import lombok.RequiredArgsConstructor;
   import lombok.extern.slf4j.Slf4j;
   import org.springframework.security.core.authority.SimpleGrantedAuthority;
   import org.springframework.security.core.userdetails.UserDetails;
   import org.springframework.security.core.userdetails.UserDetailsService;
   import org.springframework.security.core.userdetails.UsernameNotFoundException;
   import org.springframework.stereotype.Service;

   import java.util.Collections;


   @Slf4j
   @Service
   @RequiredArgsConstructor
   public class BusinesssUserDetailsSerivice implements UserDetailsService {

       private final BusinnessUserRepository businnessUserRepository;

       @Override
       public UserDetails loadUserByUsername(String identifier) throws UsernameNotFoundException {
           log.debug("Attempting to load user by identifier: {}", identifier);

           // 1. Username ilə axtarış
           var userOptByUserName = businnessUserRepository.findByUserName(identifier);
           if (userOptByUserName.isPresent()) {
               var user = userOptByUserName.get();
               log.info("User found by username: {}", user.getUserName());
               // UserDetails obyektini istifadəçinin username, password və rolu ilə qaytarır
               return new org.springframework.security.core.userdetails.User(
                       user.getUserName(),
                       user.getPassword(),
                       Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + user.getRoles().name()))
               );
           }

           // 2. Email ilə axtarış (əgər username ilə tapılmayıbsa)
           var userOptByEmail = businnessUserRepository.findByEmail(identifier);
           if (userOptByEmail.isPresent()) {
               var user = userOptByEmail.get();
               log.info("User found by email: {}", user.getEmail());
               // Burada da UserDetails obyektini istifadəçinin username, password və rolu ilə qaytarır
               // Qeyd: loadUserByUsername metodu UserDetails obyektinin username-ini istifadə edir
               // buna görə də, email ilə tapılan istifadəçi üçün də user.getUserName() qaytarmaq düzgündür
               return new org.springframework.security.core.userdetails.User(
                       user.getUserName(),
                       user.getPassword(),
                       Collections.singletonList(new SimpleGrantedAuthority("ROLE_" + user.getRoles().name()))
               );
           }

           log.warn("User not found with identifier: {}", identifier);
           throw new UsernameNotFoundException("User not found with identifier: " + identifier);
       }
   }package com.example.businessauthservice.service;

    import lombok.RequiredArgsConstructor;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.mail.javamail.JavaMailSender;
    import org.springframework.mail.javamail.MimeMessageHelper;
    import org.springframework.scheduling.annotation.Async;
    import org.springframework.stereotype.Service;

    import jakarta.mail.MessagingException;
    import jakarta.mail.internet.MimeMessage;

    @Service
    @RequiredArgsConstructor
    @Slf4j
    public class EmailService {

        private final JavaMailSender mailSender;

        @Async("taskExecutor") // `AsyncConfig`də təyin olunmuş `taskExecutor` bean-ini istifadə edir
        public void sendEmail(String to, String subject, String body) {
            try {
                MimeMessage message = mailSender.createMimeMessage();
                MimeMessageHelper helper = new MimeMessageHelper(message, true, "UTF-8"); // true for multipart, UTF-8 for encoding
                helper.setTo(to);
                helper.setSubject(subject);
                helper.setText(body, true); // true for HTML content
                mailSender.send(message);
                log.info("Email sent successfully to: {}", to);
            } catch (MessagingException e) {
                log.error("Failed to send email to {}: {}", to, e.getMessage());
                // Real tətbiqlərdə bu xətanı istifadəçiyə qaytarmaq və ya Retry mexanizmi tətbiq etmək olar.
                throw new RuntimeException("Email göndərilərkən xəta baş verdi: " + e.getMessage());
            }
        }
    }
package com.example.businessauthservice.service;

import com.example.businessauthservice.model.enumeration.Roles;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Service;

import java.security.Key;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;

@Service
@Slf4j // Loğlama üçün
public class JwtService {

    // application.yml-dan secret key-i oxuyur
    @Value("${jwt.secret}")
    private String SECRET;

    // application.yml-dan Access Tokenin bitmə müddətini (milisaniyə ilə) oxuyur
    @Value("${jwt.expiration.ms}")
    private long jwtExpirationMs;


    /**
     * Tokenin içindən istifadəçi adını (subject) çıxarır.
     *
     * @param token İşlənəcək JWT token.
     * @return Tokenin subject (username) hissəsi.
     */
    public String extractUsername(String token) {
        return extractClaim(token, Claims::getSubject);
    }

    /**
     * Tokenin içindən bitmə tarixini çıxarır.
     *
     * @param token İşlənəcək JWT token.
     * @return Tokenin bitmə tarixi (Date obyekti).
     */
    public Date extractExpiration(String token) {
        return extractClaim(token, Claims::getExpiration);
    }

    /**
     * Tokenin içindən hər hansı bir claimi çıxarır.
     *
     * @param token İşlənəcək JWT token.
     * @param claimsResolver Claim-i çıxarmaq üçün funksiya (məsələn, Claims::getSubject).
     * @param <T> Claim-in tipi.
     * @return Çıxarılmış claim dəyəri.
     */
    public <T> T extractClaim(String token, Function<Claims, T> claimsResolver) {
        final Claims claims = extractAllClaims(token);
        return claimsResolver.apply(claims);
    }

    /**
     * Tokenin bütün claimlərini çıxarır. Bu metod daxili istifadə üçündür.
     *
     * @param token İşlənəcək JWT token.
     * @return Tokenin bütün claimləri (Claims obyekti).
     */
    private Claims extractAllClaims(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(getSignKey()) // Tokenin imzasını doğrulamaq üçün gizli açar istifadə olunur
                .build()
                .parseClaimsJws(token)
                .getBody();
    }

    /**
     * Tokenin müddətinin bitib-bitmədiyini yoxlayır.
     *
     * @param token Yoxlanılacaq JWT token.
     * @return true əgər tokenin müddəti bitibsə, əks halda false.
     */
    private Boolean isTokenExpired(String token) {
        return extractExpiration(token).before(new Date());
    }

    /**
     * Tokenin etibarlılığını yoxlayır (username uyğunluğu və bitmə müddəti).
     *
     * @param token Yoxlanılacaq JWT token.
     * @param userDetails Autentifikasiya olunacaq istifadəçinin UserDetails obyekti.
     * @return true əgər token etibarlıdırsa, əks halda false.
     */
    public Boolean validateToken(String token, UserDetails userDetails) {
        final String username = extractUsername(token);
        // Tokenin içindəki username ilə UserDetails-dəki username-in uyğunluğunu və tokenin bitmədiyini yoxla
        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));
    }

    /**
     * Yeni bir JWT Access Token yaradır.
     *
     * @param userName Tokenin subject (istifadəçi adı) olacaq string.
     * @param role İstifadəçinin rolu (Roles enum-undan).
     * @return Yaradılmış JWT Access Token.
     */
    public String generateToken(String userName, Roles role) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("role", role.name()); // Rolu "role" adlı bir claim olaraq tokenə əlavə edin
        return createToken(claims, userName);
    }

    /**
     * Verilmiş claimlər və subject (istifadəçi adı) ilə token yaradır. Bu metod daxili istifadə üçündür.
     *
     * @param claims Tokendə saxlanılacaq əlavə məlumatlar.
     * @param userName Tokenin subject (istifadəçi adı).
     * @return Yaradılmış JWT token.
     */
    private String createToken(Map<String, Object> claims, String userName) {
        long now = System.currentTimeMillis();
        Date issuedAt = new Date(now);
        // Access token üçün configuration-dan alınan müddəti istifadə et
        Date expiration = new Date(now + jwtExpirationMs);

        log.debug("Generating token for user: {}, role: {}, issued at: {}, expires at: {}", userName, claims.get("role"), issuedAt, expiration);

        return Jwts.builder()
                .setClaims(claims) // Custom claimləri əlavə et
                .setSubject(userName) // Tokenin subyekti (istifadəçi adı)
                .setIssuedAt(issuedAt) // Tokenin verilmə tarixi
                .setExpiration(expiration) // Tokenin bitmə tarixi
                .signWith(getSignKey(), SignatureAlgorithm.HS256) // Tokeni gizli açarla imzala
                .compact(); // JWT stringini yarat
    }


    private Key getSignKey() {
        byte[] keyBytes = Decoders.BASE64.decode(SECRET);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}package com.example.businessauthservice.service;

 import com.example.businessauthservice.model.entity.BusinessUser;
 import com.example.businessauthservice.model.entity.RefreshToken;
 import com.example.businessauthservice.repository.BusinnessUserRepository;
 import com.example.businessauthservice.repository.RefreshTokenRepository;
 import lombok.RequiredArgsConstructor;
 import org.springframework.beans.factory.annotation.Value;
 import org.springframework.stereotype.Service;
 import org.springframework.transaction.annotation.Transactional; // Tranzaksiya üçün

 import java.time.Instant;
 import java.util.Optional;
 import java.util.UUID;

 @Service
 @RequiredArgsConstructor
 public class RefreshTokenService {

     private final RefreshTokenRepository refreshTokenRepository;
     private final BusinnessUserRepository businnessUserRepository;

     @Value("${jwt.refresh-expiration.ms}") // application.yml-dən oxumaq üçün
     private long refreshTokenExpirationMs;

     @Transactional // Tranzaksiya əlavə edin ki, əməliyyat atomik olsun
     public RefreshToken createRefreshToken(String username) {
         BusinessUser user = businnessUserRepository.findByUserName(username)
                 .orElseThrow(() -> new RuntimeException("User not found for refresh token creation: " + username));

         // Bu istifadəçi üçün mövcud Refresh Tokeni axtarın
         Optional<RefreshToken> existingToken = refreshTokenRepository.findByUser(user);

         RefreshToken refreshToken;
         if (existingToken.isPresent()) {
             // Əgər mövcud token varsa, onu yeniləyin
             refreshToken = existingToken.get();
             refreshToken.setToken(UUID.randomUUID().toString()); // Yeni unikal token stringi
             refreshToken.setExpiryDate(Instant.now().plusMillis(refreshTokenExpirationMs)); // Yeni bitmə tarixi
         } else {
             // Əgər mövcud token yoxdursa, yeni yaradın
             refreshToken = RefreshToken.builder()
                     .user(user)
                     .token(UUID.randomUUID().toString())
                     .expiryDate(Instant.now().plusMillis(refreshTokenExpirationMs))
                     .build();
         }
         return refreshTokenRepository.save(refreshToken);
     }

     public Optional<RefreshToken> findByToken(String token) {
         return refreshTokenRepository.findByToken(token);
     }

     public RefreshToken verifyExpiration(RefreshToken token) {
         if (token.getExpiryDate().compareTo(Instant.now()) < 0) {
             refreshTokenRepository.delete(token);
             throw new RuntimeException(token.getToken() + " Refresh token was expired. Please make a new signin request");
         }
         return token;
     }

     @Transactional // Tranzaksiya üçün
     public void deleteByUserId(Long userId) {
         BusinessUser user = businnessUserRepository.findById(userId).orElseThrow(
                 () -> new RuntimeException("User not found for deletion of refresh tokens"));
         refreshTokenRepository.deleteByUser(user);
     }
 }
